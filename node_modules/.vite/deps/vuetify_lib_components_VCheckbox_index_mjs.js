import {
  VSlideYTransition
} from "./chunk-6KNF7HJW.js";
import {
  VLabel
} from "./chunk-6VCWD44F.js";
import {
  Ripple,
  VIcon,
  makeDensityProps,
  useDensity
} from "./chunk-6C72MEUV.js";
import {
  MaybeTransition,
  makeTransitionProps
} from "./chunk-5JYADU64.js";
import "./chunk-7DCSA2NJ.js";
import {
  useProxiedModel
} from "./chunk-AEDKY3BO.js";
import {
  useTextColor
} from "./chunk-4KWW2QG6.js";
import {
  makeThemeProps
} from "./chunk-2HSEXNWG.js";
import "./chunk-7LLSWNWS.js";
import {
  SUPPORTS_FOCUS_VISIBLE,
  deepEqual,
  defineComponent,
  filterInputAttrs,
  genericComponent,
  getCurrentInstanceName,
  getUid,
  pick,
  propsFactory,
  useRender,
  wrapInArray
} from "./chunk-WIAOD35H.js";
import {
  computed,
  createVNode,
  inject,
  mergeProps,
  onBeforeMount,
  onBeforeUnmount,
  provide,
  ref,
  resolveDirective,
  toRef,
  vModelDynamic,
  watch,
  withDirectives
} from "./chunk-2JUOC7J6.js";
import {
  __spreadProps,
  __spreadValues
} from "./chunk-AWPMEBIP.js";

// node_modules/vuetify/lib/components/VCheckbox/VCheckbox.mjs
import "/Users/zhijunsong/Documents/vitetestbuild/node_modules/vuetify/lib/components/VCheckbox/VCheckbox.css";

// node_modules/vuetify/lib/components/VInput/VInput.mjs
import "/Users/zhijunsong/Documents/vitetestbuild/node_modules/vuetify/lib/components/VInput/VInput.css";

// node_modules/vuetify/lib/components/VMessages/VMessages.mjs
import "/Users/zhijunsong/Documents/vitetestbuild/node_modules/vuetify/lib/components/VMessages/VMessages.css";
var VMessages = defineComponent({
  name: "VMessages",
  props: __spreadValues({
    active: Boolean,
    color: String,
    messages: {
      type: [Array, String],
      default: () => []
    }
  }, makeTransitionProps({
    transition: {
      component: VSlideYTransition,
      leaveAbsolute: true,
      group: true
    }
  })),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const messages = computed(() => wrapInArray(props.messages));
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(computed(() => props.color));
    return () => createVNode(MaybeTransition, {
      "transition": props.transition,
      "tag": "div",
      "class": ["v-messages", textColorClasses.value],
      "style": textColorStyles.value
    }, {
      default: () => [props.active && messages.value.map((message, i) => createVNode("div", {
        "class": "v-messages__message",
        "key": `${i}-${messages.value}`
      }, [slots.message ? slots.message({
        message
      }) : message]))]
    });
  }
});

// node_modules/vuetify/lib/composables/form.mjs
var FormKey = Symbol.for("vuetify:form");
var makeFormProps = propsFactory({
  disabled: Boolean,
  fastFail: Boolean,
  lazyValidation: Boolean,
  readonly: Boolean,
  modelValue: {
    type: Boolean,
    default: null
  }
});
function useForm() {
  return inject(FormKey, null);
}

// node_modules/vuetify/lib/composables/validation.mjs
var makeValidationProps = propsFactory({
  disabled: Boolean,
  error: Boolean,
  errorMessages: {
    type: [Array, String],
    default: () => []
  },
  maxErrors: {
    type: [Number, String],
    default: 1
  },
  name: String,
  readonly: Boolean,
  rules: {
    type: Array,
    default: () => []
  },
  modelValue: null
});
function useValidation(props) {
  let name = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const model = useProxiedModel(props, "modelValue");
  const form = useForm();
  const internalErrorMessages = ref([]);
  const isPristine = ref(true);
  const isDirty = computed(() => wrapInArray(model.value || []).length > 0);
  const isDisabled = computed(() => !!(props.disabled || form != null && form.isDisabled.value));
  const isReadonly = computed(() => !!(props.readonly || form != null && form.isReadonly.value));
  const errorMessages = computed(() => {
    return props.errorMessages.length ? wrapInArray(props.errorMessages) : internalErrorMessages.value;
  });
  const isValid = computed(() => {
    if (props.error || errorMessages.value.length)
      return false;
    return isPristine.value ? null : true;
  });
  const isValidating = ref(false);
  const validationClasses = computed(() => {
    return {
      [`${name}--error`]: isValid.value === false,
      [`${name}--dirty`]: isDirty.value,
      [`${name}--disabled`]: isDisabled.value,
      [`${name}--readonly`]: isReadonly.value
    };
  });
  const uid = computed(() => {
    var _props$name;
    return (_props$name = props.name) != null ? _props$name : getUid();
  });
  onBeforeMount(() => {
    form == null ? void 0 : form.register(uid.value, validate, reset, resetValidation);
  });
  onBeforeUnmount(() => {
    form == null ? void 0 : form.unregister(uid.value);
  });
  watch(model, validate);
  function reset() {
    resetValidation();
    model.value = null;
  }
  function resetValidation() {
    isPristine.value = true;
    internalErrorMessages.value = [];
  }
  async function validate() {
    const results = [];
    isValidating.value = true;
    for (const rule of props.rules) {
      if (results.length >= (props.maxErrors || 1)) {
        break;
      }
      const handler = typeof rule === "function" ? rule : () => rule;
      const result = await handler(model.value);
      if (result === true)
        continue;
      if (typeof result !== "string") {
        console.warn(`${result} is not a valid value. Rule functions must return boolean true or a string.`);
        continue;
      }
      results.push(result);
    }
    internalErrorMessages.value = results;
    isValidating.value = false;
    isPristine.value = false;
    return internalErrorMessages.value;
  }
  return {
    errorMessages,
    isDirty,
    isDisabled,
    isReadonly,
    isPristine,
    isValid,
    isValidating,
    reset,
    resetValidation,
    validate,
    validationClasses
  };
}

// node_modules/vuetify/lib/components/VInput/VInput.mjs
var makeVInputProps = propsFactory(__spreadValues(__spreadValues({
  id: String,
  appendIcon: String,
  prependIcon: String,
  hideDetails: [Boolean, String],
  messages: {
    type: [Array, String],
    default: () => []
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (v) => ["horizontal", "vertical"].includes(v)
  }
}, makeDensityProps()), makeValidationProps()));
var VInput = genericComponent()({
  name: "VInput",
  props: __spreadValues({}, makeVInputProps()),
  emits: {
    "click:prepend": (e) => true,
    "click:append": (e) => true,
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      slots,
      emit
    } = _ref;
    const {
      densityClasses
    } = useDensity(props);
    const {
      errorMessages,
      isDirty,
      isDisabled,
      isReadonly,
      isPristine,
      isValid,
      isValidating,
      reset,
      resetValidation,
      validate,
      validationClasses
    } = useValidation(props);
    const uid = getUid();
    const id = computed(() => props.id || `input-${uid}`);
    const slotProps = computed(() => ({
      id,
      isDirty,
      isDisabled,
      isReadonly,
      isPristine,
      isValid,
      isValidating,
      reset,
      resetValidation,
      validate
    }));
    useRender(() => {
      var _props$messages, _slots$prepend, _slots$default, _slots$append, _slots$details;
      const hasPrepend = !!(slots.prepend || props.prependIcon);
      const hasAppend = !!(slots.append || props.appendIcon);
      const hasMessages = !!((_props$messages = props.messages) != null && _props$messages.length || errorMessages.value.length);
      const hasDetails = !props.hideDetails || props.hideDetails === "auto" && hasMessages;
      return createVNode("div", {
        "class": ["v-input", `v-input--${props.direction}`, densityClasses.value, validationClasses.value]
      }, [hasPrepend && createVNode("div", {
        "class": "v-input__prepend"
      }, [slots == null ? void 0 : (_slots$prepend = slots.prepend) == null ? void 0 : _slots$prepend.call(slots, slotProps.value), props.prependIcon && createVNode(VIcon, {
        "onClick": (e) => emit("click:prepend", e),
        "icon": props.prependIcon
      }, null)]), slots.default && createVNode("div", {
        "class": "v-input__control"
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, slotProps.value)]), hasAppend && createVNode("div", {
        "class": "v-input__append"
      }, [slots == null ? void 0 : (_slots$append = slots.append) == null ? void 0 : _slots$append.call(slots, slotProps.value), props.appendIcon && createVNode(VIcon, {
        "onClick": (e) => emit("click:append", e),
        "icon": props.appendIcon
      }, null)]), hasDetails && createVNode("div", {
        "class": "v-input__details"
      }, [createVNode(VMessages, {
        "active": hasMessages,
        "messages": errorMessages.value.length > 0 ? errorMessages.value : props.messages
      }, {
        message: slots.message
      }), (_slots$details = slots.details) == null ? void 0 : _slots$details.call(slots, slotProps.value)])]);
    });
    return {
      reset,
      resetValidation,
      validate
    };
  }
});
function filterInputProps(props) {
  return pick(props, Object.keys(VInput.props));
}

// node_modules/vuetify/lib/components/VSelectionControl/VSelectionControl.mjs
import "/Users/zhijunsong/Documents/vitetestbuild/node_modules/vuetify/lib/components/VSelectionControl/VSelectionControl.css";

// node_modules/vuetify/lib/components/VSelectionControlGroup/VSelectionControlGroup.mjs
import "/Users/zhijunsong/Documents/vitetestbuild/node_modules/vuetify/lib/components/VSelectionControlGroup/VSelectionControlGroup.css";
var VSelectionControlGroupSymbol = Symbol.for("vuetify:selection-control-group");
var VSelectionControlGroup = defineComponent({
  name: "VSelectionControlGroup",
  props: {
    disabled: Boolean,
    id: String,
    inline: Boolean,
    name: String,
    falseIcon: String,
    trueIcon: String,
    multiple: {
      type: Boolean,
      default: null
    },
    readonly: Boolean,
    type: String,
    modelValue: null
  },
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const modelValue = useProxiedModel(props, "modelValue");
    const uid = getUid();
    const id = computed(() => props.id || `v-selection-control-group-${uid}`);
    const name = computed(() => props.name || id.value);
    provide(VSelectionControlGroupSymbol, {
      disabled: toRef(props, "disabled"),
      inline: toRef(props, "inline"),
      modelValue,
      multiple: computed(() => !!props.multiple || props.multiple == null && Array.isArray(modelValue.value)),
      name,
      falseIcon: toRef(props, "falseIcon"),
      trueIcon: toRef(props, "trueIcon"),
      readonly: toRef(props, "readonly"),
      type: toRef(props, "type")
    });
    useRender(() => {
      var _slots$default;
      return createVNode("div", {
        "class": "v-selection-control-group",
        "aria-labelled-by": props.type === "radio" ? id.value : void 0,
        "role": props.type === "radio" ? "radiogroup" : void 0
      }, [slots == null ? void 0 : (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]);
    });
    return {};
  }
});

// node_modules/vuetify/lib/components/VSelectionControl/VSelectionControl.mjs
var makeSelectionControlProps = propsFactory(__spreadValues(__spreadValues({
  color: String,
  disabled: Boolean,
  error: Boolean,
  id: String,
  inline: Boolean,
  label: String,
  falseIcon: String,
  trueIcon: String,
  ripple: {
    type: Boolean,
    default: true
  },
  multiple: {
    type: Boolean,
    default: null
  },
  name: String,
  readonly: Boolean,
  trueValue: null,
  falseValue: null,
  modelValue: null,
  type: String,
  value: null,
  valueComparator: {
    type: Function,
    default: deepEqual
  }
}, makeThemeProps()), makeDensityProps()));
function useSelectionControl(props) {
  const group = inject(VSelectionControlGroupSymbol, void 0);
  const {
    densityClasses
  } = useDensity(props);
  const modelValue = useProxiedModel(props, "modelValue");
  const trueValue = computed(() => props.trueValue !== void 0 ? props.trueValue : props.value !== void 0 ? props.value : true);
  const falseValue = computed(() => props.falseValue !== void 0 ? props.falseValue : false);
  const isMultiple = computed(() => (group == null ? void 0 : group.multiple.value) || !!props.multiple || props.multiple == null && Array.isArray(modelValue.value));
  const model = computed({
    get() {
      const val = group ? group.modelValue.value : modelValue.value;
      return isMultiple.value ? val.some((v) => props.valueComparator(v, trueValue.value)) : props.valueComparator(val, trueValue.value);
    },
    set(val) {
      const currentValue = val ? trueValue.value : falseValue.value;
      let newVal = currentValue;
      if (isMultiple.value) {
        newVal = val ? [...wrapInArray(modelValue.value), currentValue] : wrapInArray(modelValue.value).filter((item) => !props.valueComparator(item, trueValue.value));
      }
      if (group) {
        group.modelValue.value = newVal;
      } else {
        modelValue.value = newVal;
      }
    }
  });
  const {
    textColorClasses,
    textColorStyles
  } = useTextColor(computed(() => {
    return model.value && !props.error && !props.disabled ? props.color : void 0;
  }));
  const icon = computed(() => {
    var _group$trueIcon$value, _group$falseIcon$valu;
    return model.value ? (_group$trueIcon$value = group == null ? void 0 : group.trueIcon.value) != null ? _group$trueIcon$value : props.trueIcon : (_group$falseIcon$valu = group == null ? void 0 : group.falseIcon.value) != null ? _group$falseIcon$valu : props.falseIcon;
  });
  return {
    group,
    densityClasses,
    trueValue,
    falseValue,
    model,
    textColorClasses,
    textColorStyles,
    icon
  };
}
var VSelectionControl = genericComponent()({
  name: "VSelectionControl",
  directives: {
    Ripple
  },
  inheritAttrs: false,
  props: makeSelectionControlProps(),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      densityClasses,
      group,
      icon,
      model,
      textColorClasses,
      textColorStyles,
      trueValue
    } = useSelectionControl(props);
    const uid = getUid();
    const id = computed(() => props.id || `input-${uid}`);
    const isFocused = ref(false);
    const isFocusVisible = ref(false);
    const input = ref();
    function onFocus(e) {
      isFocused.value = true;
      if (!SUPPORTS_FOCUS_VISIBLE || SUPPORTS_FOCUS_VISIBLE && e.target.matches(":focus-visible")) {
        isFocusVisible.value = true;
      }
    }
    function onBlur() {
      isFocused.value = false;
      isFocusVisible.value = false;
    }
    useRender(() => {
      var _group$type$value, _slots$default, _group$name$value, _slots$input;
      const label = slots.label ? slots.label({
        label: props.label,
        props: {
          for: id.value
        }
      }) : props.label;
      const type = (_group$type$value = group == null ? void 0 : group.type.value) != null ? _group$type$value : props.type;
      return createVNode("div", {
        "class": ["v-selection-control", {
          "v-selection-control--dirty": model.value,
          "v-selection-control--disabled": props.disabled,
          "v-selection-control--error": props.error,
          "v-selection-control--focused": isFocused.value,
          "v-selection-control--focus-visible": isFocusVisible.value,
          "v-selection-control--inline": (group == null ? void 0 : group.inline.value) || props.inline
        }, densityClasses.value]
      }, [createVNode("div", {
        "class": ["v-selection-control__wrapper", textColorClasses.value]
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots), withDirectives(createVNode("div", {
        "class": ["v-selection-control__input"],
        "style": textColorStyles.value
      }, [icon.value && createVNode(VIcon, {
        "icon": icon.value
      }, null), withDirectives(createVNode("input", mergeProps({
        "onUpdate:modelValue": ($event) => model.value = $event,
        "ref": input,
        "disabled": props.disabled,
        "id": id.value,
        "onBlur": onBlur,
        "onFocus": onFocus,
        "readonly": props.readonly,
        "type": type,
        "value": trueValue.value,
        "name": (_group$name$value = group == null ? void 0 : group.name.value) != null ? _group$name$value : props.name,
        "aria-checked": type === "checkbox" ? model.value : void 0
      }, attrs), null), [[vModelDynamic, model.value]]), (_slots$input = slots.input) == null ? void 0 : _slots$input.call(slots, {
        model,
        textColorClasses,
        props: {
          onFocus,
          onBlur,
          id: id.value
        }
      })]), [[resolveDirective("ripple"), props.ripple && [!props.disabled && !props.readonly, null, ["center", "circle"]]]])]), createVNode(VLabel, {
        "for": id.value
      }, {
        default: () => [label]
      })]);
    });
    return {
      isFocused,
      input
    };
  }
});
function filterControlProps(props) {
  return pick(props, Object.keys(VSelectionControl.props));
}

// node_modules/vuetify/lib/components/VCheckbox/VCheckbox.mjs
var VCheckbox = defineComponent({
  name: "VCheckbox",
  inheritAttrs: false,
  props: __spreadProps(__spreadValues(__spreadValues({
    indeterminate: Boolean,
    indeterminateIcon: {
      type: String,
      default: "$checkboxIndeterminate"
    }
  }, makeVInputProps()), makeSelectionControlProps()), {
    falseIcon: {
      type: String,
      default: "$checkboxOff"
    },
    trueIcon: {
      type: String,
      default: "$checkboxOn"
    }
  }),
  emits: {
    "update:indeterminate": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const indeterminate = useProxiedModel(props, "indeterminate");
    const falseIcon = computed(() => {
      return indeterminate.value ? props.indeterminateIcon : props.falseIcon;
    });
    const trueIcon = computed(() => {
      return indeterminate.value ? props.indeterminateIcon : props.trueIcon;
    });
    function onChange() {
      if (indeterminate.value) {
        indeterminate.value = false;
      }
    }
    useRender(() => {
      const [inputAttrs, controlAttrs] = filterInputAttrs(attrs);
      const [inputProps, _1] = filterInputProps(props);
      const [controlProps, _2] = filterControlProps(props);
      return createVNode(VInput, mergeProps({
        "class": "v-checkbox"
      }, inputAttrs, inputProps), __spreadProps(__spreadValues({}, slots), {
        default: (_ref2) => {
          let {
            isDisabled,
            isReadonly
          } = _ref2;
          return createVNode(VSelectionControl, mergeProps(controlProps, {
            "type": "checkbox",
            "onUpdate:modelValue": onChange,
            "falseIcon": falseIcon.value,
            "trueIcon": trueIcon.value,
            "aria-checked": indeterminate.value ? "mixed" : void 0,
            "disabled": isDisabled.value,
            "readonly": isReadonly.value
          }, controlAttrs), slots);
        }
      }));
    });
    return {};
  }
});
export {
  VCheckbox
};
//# sourceMappingURL=vuetify_lib_components_VCheckbox_index_mjs.js.map
