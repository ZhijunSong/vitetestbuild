{
  "version": 3,
  "sources": ["../../vuetify/src/composables/router.tsx"],
  "sourcesContent": ["// Utilities\nimport { getCurrentInstance, propsFactory } from '@/util'\nimport {\n  computed,\n  onBeforeUnmount,\n  onMounted,\n  resolveDynamicComponent,\n  toRef,\n} from 'vue'\n\n// Types\nimport type { ComputedRef, PropType, Ref, SetupContext } from 'vue'\nimport type {\n  RouterLink as _RouterLink,\n  useLink as _useLink,\n  NavigationGuardNext,\n  RouteLocationNormalizedLoaded,\n  RouteLocationRaw,\n  Router,\n} from 'vue-router'\n\nexport function useRoute (): Ref<RouteLocationNormalizedLoaded | undefined> {\n  const vm = getCurrentInstance('useRoute')\n\n  return computed(() => vm?.proxy?.$route)\n}\n\nexport function useRouter (): Router | undefined {\n  return getCurrentInstance('useRouter')?.proxy?.$router\n}\n\nexport interface LinkProps {\n  href?: string\n  replace?: boolean\n  to?: RouteLocationRaw\n}\n\nexport interface UseLink extends Omit<Partial<ReturnType<typeof _useLink>>, 'href'> {\n  isLink: ComputedRef<boolean>\n  isClickable: ComputedRef<boolean>\n  href: Ref<string | undefined>\n}\n\nexport function useLink (props: LinkProps, attrs: SetupContext['attrs']): UseLink {\n  const RouterLink = resolveDynamicComponent('RouterLink') as typeof _RouterLink | string\n\n  const isLink = computed(() => !!(props.href || props.to))\n  const isClickable = computed(() => {\n    return isLink?.value || !!(attrs.onClick || attrs.onClickOnce)\n  })\n\n  if (typeof RouterLink === 'string') {\n    return {\n      isLink,\n      isClickable,\n      href: toRef(props, 'href'),\n    }\n  }\n\n  const link = props.to ? RouterLink.useLink(props as Required<LinkProps>) : undefined\n\n  return {\n    ...link,\n    isLink,\n    isClickable,\n    href: computed(() => props.to ? link?.route.value.href : props.href),\n  }\n}\n\nexport const makeRouterProps = propsFactory({\n  href: String,\n  replace: Boolean,\n  to: [String, Object] as PropType<RouteLocationRaw>,\n}, 'router')\n\nexport function useBackButton (cb: (next: NavigationGuardNext) => void) {\n  const router = useRouter()\n  let popped = false\n  let removeGuard: (() => void) | undefined\n\n  onMounted(() => {\n    window.addEventListener('popstate', onPopstate)\n    removeGuard = router?.beforeEach((to, from, next) => {\n      setTimeout(() => popped ? cb(next) : next())\n    })\n  })\n  onBeforeUnmount(() => {\n    window.removeEventListener('popstate', onPopstate)\n    removeGuard?.()\n  })\n\n  function onPopstate (e: PopStateEvent) {\n    if (e.state?.replaced) return\n\n    popped = true\n    setTimeout(() => (popped = false))\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;AA2BO,qBAA0C;AAAA,MAAA,qBAAA;AAC/C,SAAA,uBAAO,mBAAmB,WAAD,MAAzB,OAAA,SAAA,yBAAO,oBAAiC,UAAxC,OAAA,SAAO,sBAAwC;AAChD;AAcM,iBAAkB,OAAkB,OAAuC;AAChF,QAAM,aAAa,wBAAwB,YAAD;AAE1C,QAAM,SAAS,SAAS,MAAM,CAAC,CAAE,OAAM,QAAQ,MAAM,GAA9B;AACvB,QAAM,cAAc,SAAS,MAAM;AACjC,WAAO,WAAM,OAAN,SAAA,OAAQ,UAAS,CAAC,CAAE,OAAM,WAAW,MAAM;EACnD,CAF2B;AAI5B,MAAI,OAAO,eAAe,UAAU;AAClC,WAAO;MACL;MACA;MACA,MAAM,MAAM,OAAO,MAAR;IAHN;EAKR;AAED,QAAM,OAAO,MAAM,KAAK,WAAW,QAAQ,KAAnB,IAAmD;AAE3E,SAAO,iCACF,OADE;IAEL;IACA;IACA,MAAM,SAAS,MAAM,MAAM,KAAK,QAAX,OAAA,SAAW,KAAM,MAAM,MAAM,OAAO,MAAM,IAAjD;EAJT;AAMR;AAEM,IAAM,kBAAkB,aAAa;EAC1C,MAAM;EACN,SAAS;EACT,IAAI,CAAC,QAAQ,MAAT;AAHsC,GAIzC,QAJwC;",
  "names": []
}
