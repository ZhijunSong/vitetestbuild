import {
  VDialogTransition
} from "./chunk-ECUIDIJC.js";
import {
  makeDimensionProps,
  useDimension
} from "./chunk-CHKNSBGH.js";
import {
  MaybeTransition,
  makeTransitionProps
} from "./chunk-ZORWLBYQ.js";
import {
  useRtl
} from "./chunk-7ACDKDXF.js";
import {
  useBackButton
} from "./chunk-AVUVHU2D.js";
import {
  useProxiedModel
} from "./chunk-OLD5LPCW.js";
import {
  useBackgroundColor
} from "./chunk-7WR4I7IW.js";
import {
  makeThemeProps,
  provideTheme
} from "./chunk-3GMUFSDV.js";
import {
  Box,
  IN_BROWSER,
  SUPPORTS_FOCUS_VISIBLE,
  attachedRoot,
  convertToUnit,
  genericComponent,
  getCurrentInstance,
  getScrollParent,
  getScrollParents,
  getUid,
  hasScrollbar,
  isComponentInstance,
  isFixedPosition,
  nullifyTransforms,
  propsFactory,
  standardEasing,
  useRender
} from "./chunk-ALJB2OGJ.js";
import {
  Fragment,
  Teleport,
  Transition,
  computed,
  createVNode,
  effectScope,
  inject,
  mergeProps,
  nextTick,
  onScopeDispose,
  provide,
  readonly,
  ref,
  resolveDirective,
  toHandlers,
  toRaw,
  vShow,
  warn,
  watch,
  watchEffect,
  withDirectives
} from "./chunk-2JUOC7J6.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues
} from "./chunk-AWPMEBIP.js";

// node_modules/vuetify/lib/components/VMenu/VMenu.mjs
import "/Users/zhijunsong/Documents/vitetestbuild/node_modules/vuetify/lib/components/VMenu/VMenu.css";

// node_modules/vuetify/lib/components/VOverlay/VOverlay.mjs
import "/Users/zhijunsong/Documents/vitetestbuild/node_modules/vuetify/lib/components/VOverlay/VOverlay.css";

// node_modules/vuetify/lib/composables/delay.mjs
var makeDelayProps = propsFactory({
  closeDelay: [Number, String],
  openDelay: [Number, String]
}, "delay");
function useDelay(props, cb) {
  const delays = {};
  const runDelayFactory = (prop) => () => {
    if (!IN_BROWSER)
      return Promise.resolve(true);
    const active = prop === "openDelay";
    delays.closeDelay && window.clearTimeout(delays.closeDelay);
    delete delays.closeDelay;
    delays.openDelay && window.clearTimeout(delays.openDelay);
    delete delays.openDelay;
    return new Promise((resolve) => {
      var _props$prop;
      const delay = parseInt((_props$prop = props[prop]) != null ? _props$prop : 0, 10);
      delays[prop] = window.setTimeout(() => {
        cb == null ? void 0 : cb(active);
        resolve(active);
      }, delay);
    });
  };
  return {
    runCloseDelay: runDelayFactory("closeDelay"),
    runOpenDelay: runDelayFactory("openDelay")
  };
}

// node_modules/vuetify/lib/components/VOverlay/useActivator.mjs
var makeActivatorProps = propsFactory(__spreadValues({
  activator: [String, Object],
  activatorProps: {
    type: Object,
    default: () => ({})
  },
  openOnClick: {
    type: Boolean,
    default: void 0
  },
  openOnHover: Boolean,
  openOnFocus: {
    type: Boolean,
    default: void 0
  }
}, makeDelayProps()));
function useActivator(props, isActive) {
  const activatorEl = ref();
  let isHovered = false;
  let isFocused = false;
  const openOnFocus = computed(() => props.openOnFocus || props.openOnFocus == null && props.openOnHover);
  const openOnClick = computed(() => props.openOnClick || props.openOnClick == null && !props.openOnHover && !openOnFocus.value);
  const {
    runOpenDelay,
    runCloseDelay
  } = useDelay(props, (value) => {
    if (value === (props.openOnHover && isHovered || openOnFocus.value && isFocused)) {
      isActive.value = value;
    }
  });
  const availableEvents = {
    click: (e) => {
      e.stopPropagation();
      activatorEl.value = e.currentTarget || e.target;
      isActive.value = !isActive.value;
    },
    mouseenter: (e) => {
      isHovered = true;
      activatorEl.value = e.currentTarget || e.target;
      runOpenDelay();
    },
    mouseleave: (e) => {
      isHovered = false;
      runCloseDelay();
    },
    focus: (e) => {
      if (SUPPORTS_FOCUS_VISIBLE && !e.target.matches(":focus-visible"))
        return;
      isFocused = true;
      e.stopPropagation();
      activatorEl.value = e.currentTarget || e.target;
      runOpenDelay();
    },
    blur: (e) => {
      isFocused = false;
      e.stopPropagation();
      runCloseDelay();
    }
  };
  const activatorEvents = computed(() => {
    const events = {};
    if (openOnClick.value) {
      events.click = availableEvents.click;
    }
    if (props.openOnHover) {
      events.mouseenter = availableEvents.mouseenter;
      events.mouseleave = availableEvents.mouseleave;
    }
    if (openOnFocus.value) {
      events.focus = availableEvents.focus;
      events.blur = availableEvents.blur;
    }
    return events;
  });
  const activatorRef = ref();
  watchEffect(() => {
    if (!activatorRef.value)
      return;
    nextTick(() => {
      const activator = activatorRef.value;
      activatorEl.value = isComponentInstance(activator) ? activator.$el : activator;
    });
  });
  const vm = getCurrentInstance("useActivator");
  let scope;
  watch(() => !!props.activator, (val) => {
    if (val && IN_BROWSER) {
      scope = effectScope();
      scope.run(() => {
        _useActivator(props, vm, {
          activatorEl,
          activatorRef,
          activatorEvents
        });
      });
    } else if (scope) {
      scope.stop();
    }
  }, {
    flush: "post",
    immediate: true
  });
  return {
    activatorEl,
    activatorRef,
    activatorEvents
  };
}
function _useActivator(props, vm, _ref) {
  let {
    activatorEl,
    activatorEvents
  } = _ref;
  watch(() => props.activator, (val, oldVal) => {
    if (oldVal && val !== oldVal) {
      const activator = getActivator(oldVal);
      activator && unbindActivatorProps(activator);
    }
    if (val) {
      nextTick(() => bindActivatorProps());
    }
  }, {
    immediate: true
  });
  watch(() => props.activatorProps, () => {
    bindActivatorProps();
  });
  onScopeDispose(() => {
    unbindActivatorProps();
  });
  function bindActivatorProps() {
    let el = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getActivator();
    let _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : props.activatorProps;
    if (!el)
      return;
    Object.entries(activatorEvents.value).forEach((_ref2) => {
      let [name, cb] = _ref2;
      el.addEventListener(name, cb);
    });
    Object.keys(_props).forEach((k) => {
      if (_props[k] == null) {
        el.removeAttribute(k);
      } else {
        el.setAttribute(k, _props[k]);
      }
    });
  }
  function unbindActivatorProps() {
    let el = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getActivator();
    let _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : props.activatorProps;
    if (!el)
      return;
    Object.entries(activatorEvents.value).forEach((_ref3) => {
      let [name, cb] = _ref3;
      el.removeEventListener(name, cb);
    });
    Object.keys(_props).forEach((k) => {
      el.removeAttribute(k);
    });
  }
  function getActivator() {
    var _activator;
    let selector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : props.activator;
    let activator;
    if (selector) {
      if (selector === "parent") {
        var _vm$proxy, _vm$proxy$$el;
        activator = vm == null ? void 0 : (_vm$proxy = vm.proxy) == null ? void 0 : (_vm$proxy$$el = _vm$proxy.$el) == null ? void 0 : _vm$proxy$$el.parentNode;
      } else if (typeof selector === "string") {
        activator = document.querySelector(selector);
      } else if ("$el" in selector) {
        activator = selector.$el;
      } else {
        activator = selector;
      }
    }
    activatorEl.value = ((_activator = activator) == null ? void 0 : _activator.nodeType) === Node.ELEMENT_NODE ? activator : null;
    return activatorEl.value;
  }
}

// node_modules/vuetify/lib/components/VOverlay/util/anchor.mjs
function parseAnchor(anchor) {
  let [side, align] = anchor.split(" ");
  if (!align) {
    align = side === "top" || side === "bottom" ? "start" : side === "start" || side === "end" ? "top" : "center";
  }
  return {
    side,
    align
  };
}
function oppositeAnchor(anchor) {
  return {
    side: {
      center: "center",
      top: "bottom",
      bottom: "top",
      start: "end",
      end: "start"
    }[anchor.side],
    align: anchor.align
  };
}
function physicalAnchor(anchor, el) {
  var _map$side, _map$align;
  const {
    side,
    align
  } = anchor;
  const {
    direction
  } = window.getComputedStyle(el);
  const map = direction === "ltr" ? {
    start: "left",
    end: "right"
  } : {
    start: "right",
    end: "left"
  };
  return ((_map$side = map[side]) != null ? _map$side : side) + " " + ((_map$align = map[align]) != null ? _map$align : align);
}

// node_modules/vuetify/lib/components/VOverlay/util/point.mjs
function elementToViewport(point, offset) {
  return {
    x: point.x + offset.x,
    y: point.y + offset.y
  };
}
function getOffset(a, b) {
  return {
    x: a.x - b.x,
    y: a.y - b.y
  };
}
function anchorToPoint(anchor, box) {
  if (anchor.side === "top" || anchor.side === "bottom") {
    const {
      side,
      align
    } = anchor;
    const x = align === "start" ? 0 : align === "center" ? box.width / 2 : align === "end" ? box.width : align;
    const y = side === "top" ? 0 : side === "bottom" ? box.height : side;
    return elementToViewport({
      x,
      y
    }, box);
  } else if (anchor.side === "start" || anchor.side === "end") {
    const {
      side,
      align
    } = anchor;
    const x = side === "start" ? 0 : side === "end" ? box.width : side;
    const y = align === "top" ? 0 : align === "center" ? box.height / 2 : align === "bottom" ? box.height : align;
    return elementToViewport({
      x,
      y
    }, box);
  }
  return elementToViewport({
    x: box.width / 2,
    y: box.height / 2
  }, box);
}

// node_modules/vuetify/lib/components/VOverlay/positionStrategies.mjs
var positionStrategies = {
  static: staticPositionStrategy,
  connected: connectedPositionStrategy
};
var makePositionStrategyProps = propsFactory({
  positionStrategy: {
    type: [String, Function],
    default: "static",
    validator: (val) => typeof val === "function" || val in positionStrategies
  },
  anchor: {
    type: String,
    default: "bottom"
  },
  origin: {
    type: String,
    default: "auto"
  },
  offset: [Number, String]
});
function usePositionStrategies(props, data) {
  const contentStyles = ref({});
  const updatePosition = ref();
  let scope;
  watchEffect(async () => {
    var _scope;
    (_scope = scope) == null ? void 0 : _scope.stop();
    updatePosition.value = void 0;
    if (!(IN_BROWSER && data.isActive.value && props.positionStrategy))
      return;
    scope = effectScope();
    await nextTick();
    scope.run(() => {
      if (typeof props.positionStrategy === "function") {
        var _props$positionStrate;
        updatePosition.value = (_props$positionStrate = props.positionStrategy(data, props, contentStyles)) == null ? void 0 : _props$positionStrate.updatePosition;
      } else {
        var _positionStrategies$p;
        updatePosition.value = (_positionStrategies$p = positionStrategies[props.positionStrategy](data, props, contentStyles)) == null ? void 0 : _positionStrategies$p.updatePosition;
      }
    });
  });
  IN_BROWSER && window.addEventListener("resize", onResize, {
    passive: true
  });
  onScopeDispose(() => {
    var _scope2;
    IN_BROWSER && window.removeEventListener("resize", onResize);
    updatePosition.value = void 0;
    (_scope2 = scope) == null ? void 0 : _scope2.stop();
  });
  function onResize(e) {
    var _updatePosition$value;
    (_updatePosition$value = updatePosition.value) == null ? void 0 : _updatePosition$value.call(updatePosition, e);
  }
  return {
    contentStyles,
    updatePosition
  };
}
function staticPositionStrategy() {
}
function connectedPositionStrategy(data, props, contentStyles) {
  const activatorFixed = isFixedPosition(data.activatorEl.value);
  if (activatorFixed) {
    Object.assign(contentStyles.value, {
      position: "fixed"
    });
  }
  const preferredAnchor = computed(() => parseAnchor(props.anchor));
  const preferredOrigin = computed(() => props.origin === "overlap" ? preferredAnchor.value : props.origin === "auto" ? oppositeAnchor(preferredAnchor.value) : parseAnchor(props.origin));
  const doesOverlap = computed(() => {
    return preferredAnchor.value.side === preferredOrigin.value.side;
  });
  const configuredMaxHeight = computed(() => {
    const val = parseFloat(props.maxHeight);
    return isNaN(val) ? Infinity : val;
  });
  const configuredMinWidth = computed(() => {
    const val = parseFloat(props.minWidth);
    return isNaN(val) ? Infinity : val;
  });
  let observe = false;
  if (IN_BROWSER) {
    const observer = new ResizeObserver(() => {
      if (observe)
        updatePosition();
    });
    observer.observe(data.activatorEl.value);
    observer.observe(data.contentEl.value);
    onScopeDispose(() => {
      observer.disconnect();
    });
  }
  function updatePosition() {
    var _props$maxWidth;
    observe = false;
    requestAnimationFrame(() => {
      requestAnimationFrame(() => observe = true);
    });
    const targetBox = data.activatorEl.value.getBoundingClientRect();
    if (props.offset) {
      targetBox.x -= +props.offset;
      targetBox.y -= +props.offset;
      targetBox.width += +props.offset * 2;
      targetBox.height += +props.offset * 2;
    }
    const scrollParent = getScrollParent(data.contentEl.value);
    const viewportWidth = scrollParent.clientWidth;
    const viewportHeight = Math.min(scrollParent.clientHeight, window.innerHeight);
    let contentBox;
    {
      const scrollables = /* @__PURE__ */ new Map();
      data.contentEl.value.querySelectorAll("*").forEach((el) => {
        const x2 = el.scrollLeft;
        const y2 = el.scrollTop;
        if (x2 || y2) {
          scrollables.set(el, [x2, y2]);
        }
      });
      const initialMaxWidth = data.contentEl.value.style.maxWidth;
      const initialMaxHeight = data.contentEl.value.style.maxHeight;
      data.contentEl.value.style.removeProperty("max-width");
      data.contentEl.value.style.removeProperty("max-height");
      contentBox = nullifyTransforms(data.contentEl.value);
      contentBox.x -= parseFloat(data.contentEl.value.style.left) || 0;
      contentBox.y -= parseFloat(data.contentEl.value.style.top) || 0;
      data.contentEl.value.style.maxWidth = initialMaxWidth;
      data.contentEl.value.style.maxHeight = initialMaxHeight;
      scrollables.forEach((position, el) => {
        el.scrollTo(...position);
      });
    }
    const contentHeight = Math.min(configuredMaxHeight.value, contentBox.height);
    const maxFreeSpaceWidth = props.maxWidth === void 0 ? Number.MAX_VALUE : parseInt((_props$maxWidth = props.maxWidth) != null ? _props$maxWidth : 0, 10);
    const viewportMargin = 12;
    const freeSpace = {
      top: targetBox.top - viewportMargin,
      bottom: viewportHeight - targetBox.bottom - viewportMargin,
      left: Math.min(targetBox.left - viewportMargin, maxFreeSpaceWidth),
      right: Math.min(viewportWidth - targetBox.right - viewportMargin, maxFreeSpaceWidth)
    };
    const fitsY = preferredAnchor.value.side === "bottom" && contentHeight <= freeSpace.bottom || preferredAnchor.value.side === "top" && contentHeight <= freeSpace.top;
    const anchor = fitsY ? preferredAnchor.value : preferredAnchor.value.side === "bottom" && freeSpace.top > freeSpace.bottom || preferredAnchor.value.side === "top" && freeSpace.bottom > freeSpace.top ? oppositeAnchor(preferredAnchor.value) : preferredAnchor.value;
    const origin = fitsY ? preferredOrigin.value : oppositeAnchor(anchor);
    const canFill = doesOverlap.value || ["center", "top", "bottom"].includes(anchor.side);
    const maxWidth = canFill ? Math.min(viewportWidth, Math.max(targetBox.width, viewportWidth - viewportMargin * 2)) : anchor.side === "end" ? freeSpace.right : anchor.side === "start" ? freeSpace.left : null;
    const minWidth = Math.min(configuredMinWidth.value, maxWidth, targetBox.width);
    const maxHeight = fitsY ? configuredMaxHeight.value : Math.min(configuredMaxHeight.value, Math.floor(anchor.side === "top" ? freeSpace.top : freeSpace.bottom));
    const targetPoint = anchorToPoint(anchor, targetBox);
    const contentPoint = anchorToPoint(origin, new Box(__spreadProps(__spreadValues({}, contentBox), {
      height: Math.min(contentHeight, maxHeight)
    })));
    const {
      x,
      y
    } = getOffset(targetPoint, contentPoint);
    Object.assign(contentStyles.value, {
      "--v-overlay-anchor-origin": physicalAnchor(anchor, data.activatorEl.value),
      top: convertToUnit(Math.round(y)),
      left: convertToUnit(Math.round(x)),
      transformOrigin: physicalAnchor(origin, data.activatorEl.value),
      minWidth: convertToUnit(minWidth),
      maxWidth: convertToUnit(maxWidth),
      maxHeight: convertToUnit(maxHeight)
    });
  }
  watch(() => [preferredAnchor.value, preferredOrigin.value, props.offset], () => updatePosition(), {
    immediate: !activatorFixed
  });
  if (activatorFixed)
    nextTick(() => updatePosition());
  requestAnimationFrame(() => {
    if (contentStyles.value.maxHeight)
      updatePosition();
  });
  return {
    updatePosition
  };
}

// node_modules/vuetify/lib/components/VOverlay/requestNewFrame.mjs
var clean = true;
var frames = [];
function requestNewFrame(cb) {
  if (!clean || frames.length) {
    frames.push(cb);
    run();
  } else {
    clean = false;
    cb();
    run();
  }
}
var raf = -1;
function run() {
  cancelAnimationFrame(raf);
  raf = requestAnimationFrame(() => {
    const frame = frames.shift();
    if (frame)
      frame();
    if (frames.length)
      run();
    else
      clean = true;
  });
}

// node_modules/vuetify/lib/components/VOverlay/scrollStrategies.mjs
var scrollStrategies = {
  none: null,
  close: closeScrollStrategy,
  block: blockScrollStrategy,
  reposition: repositionScrollStrategy
};
var makeScrollStrategyProps = propsFactory({
  scrollStrategy: {
    type: [String, Function],
    default: "block",
    validator: (val) => typeof val === "function" || val in scrollStrategies
  }
});
function useScrollStrategies(props, data) {
  if (!IN_BROWSER)
    return;
  let scope;
  watchEffect(async () => {
    var _scope;
    (_scope = scope) == null ? void 0 : _scope.stop();
    if (!(data.isActive.value && props.scrollStrategy))
      return;
    scope = effectScope();
    await nextTick();
    scope.run(() => {
      if (typeof props.scrollStrategy === "function") {
        props.scrollStrategy(data);
      } else {
        var _scrollStrategies$pro;
        (_scrollStrategies$pro = scrollStrategies[props.scrollStrategy]) == null ? void 0 : _scrollStrategies$pro.call(scrollStrategies, data);
      }
    });
  });
}
function closeScrollStrategy(data) {
  var _data$activatorEl$val;
  function onScroll(e) {
    data.isActive.value = false;
  }
  bindScroll((_data$activatorEl$val = data.activatorEl.value) != null ? _data$activatorEl$val : data.contentEl.value, onScroll);
}
function blockScrollStrategy(data) {
  var _data$root$value;
  const scrollElements = [.../* @__PURE__ */ new Set([...getScrollParents(data.activatorEl.value), ...getScrollParents(data.contentEl.value)])].filter((el) => !el.classList.contains("v-overlay-scroll-blocked"));
  const scrollbarWidth = window.innerWidth - document.documentElement.offsetWidth;
  const scrollableParent = ((el) => hasScrollbar(el) && el)(((_data$root$value = data.root.value) == null ? void 0 : _data$root$value.offsetParent) || document.documentElement);
  if (scrollableParent) {
    data.root.value.classList.add("v-overlay--scroll-blocked");
  }
  scrollElements.forEach((el, i) => {
    if (el === document.documentElement && /iphone|ipad|ipod/i.test(navigator.userAgent)) {
      el.style.setProperty("--v-ios-body-scroll-x", convertToUnit(-el.scrollLeft));
      el.style.setProperty("--v-ios-body-scroll-y", convertToUnit(-el.scrollTop));
    }
    el.style.setProperty("--v-scrollbar-offset", convertToUnit(scrollbarWidth));
    el.classList.add("v-overlay-scroll-blocked");
  });
  onScopeDispose(() => {
    scrollElements.forEach((el, i) => {
      el.style.removeProperty("--v-ios-body-scroll-x");
      el.style.removeProperty("--v-ios-body-scroll-y");
      el.style.removeProperty("--v-scrollbar-offset");
      el.classList.remove("v-overlay-scroll-blocked");
    });
    if (scrollableParent) {
      data.root.value.classList.remove("v-overlay--scroll-blocked");
    }
  });
}
function repositionScrollStrategy(data) {
  var _data$activatorEl$val2;
  let slow = false;
  let raf2 = -1;
  function update(e) {
    requestNewFrame(() => {
      var _data$updatePosition$, _data$updatePosition;
      const start = performance.now();
      (_data$updatePosition$ = (_data$updatePosition = data.updatePosition).value) == null ? void 0 : _data$updatePosition$.call(_data$updatePosition, e);
      const time = performance.now() - start;
      slow = time / (1e3 / 60) > 2;
    });
  }
  bindScroll((_data$activatorEl$val2 = data.activatorEl.value) != null ? _data$activatorEl$val2 : data.contentEl.value, (e) => {
    if (slow) {
      cancelAnimationFrame(raf2);
      raf2 = requestAnimationFrame(() => {
        raf2 = requestAnimationFrame(() => {
          update(e);
        });
      });
    } else {
      update(e);
    }
  });
}
function bindScroll(el, onScroll) {
  const scrollElements = [document, ...getScrollParents(el)];
  scrollElements.forEach((el2) => {
    el2.addEventListener("scroll", onScroll, {
      passive: true
    });
  });
  onScopeDispose(() => {
    scrollElements.forEach((el2) => {
      el2.removeEventListener("scroll", onScroll);
    });
  });
}

// node_modules/vuetify/lib/composables/teleport.mjs
function useTeleport(target) {
  const teleportTarget = computed(() => {
    const _target = target.value;
    if (_target === true || !IN_BROWSER)
      return void 0;
    const targetElement = _target === false ? document.body : typeof _target === "string" ? document.querySelector(_target) : _target;
    if (targetElement == null) {
      warn(`Unable to locate target ${_target}`);
      return void 0;
    }
    if (!useTeleport.cache.has(targetElement)) {
      const el = document.createElement("div");
      el.className = "v-overlay-container";
      targetElement.appendChild(el);
      useTeleport.cache.set(targetElement, el);
    }
    return useTeleport.cache.get(targetElement);
  });
  return {
    teleportTarget
  };
}
useTeleport.cache = /* @__PURE__ */ new WeakMap();

// node_modules/vuetify/lib/composables/lazy.mjs
var makeLazyProps = propsFactory({
  eager: Boolean
}, "lazy");
function useLazy(props, active) {
  const isBooted = ref(false);
  const hasContent = computed(() => isBooted.value || props.eager || active.value);
  watch(active, () => isBooted.value = true);
  function onAfterLeave() {
    if (!props.eager)
      isBooted.value = false;
  }
  return {
    isBooted,
    hasContent,
    onAfterLeave
  };
}

// node_modules/vuetify/lib/composables/stack.mjs
var stack = ref([]);
function useStack(isActive) {
  const vm = getCurrentInstance("useStack");
  let scope;
  watch(isActive, (val) => {
    if (val) {
      scope = effectScope();
      scope.run(() => {
        stack.value.push(vm);
        onScopeDispose(() => {
          const idx = stack.value.indexOf(vm);
          stack.value.splice(idx, 1);
        });
      });
    } else {
      var _scope;
      (_scope = scope) == null ? void 0 : _scope.stop();
    }
  }, {
    immediate: true
  });
  const isTop = ref(true);
  watchEffect(() => {
    const _isTop = toRaw(stack.value[stack.value.length - 1]) === vm;
    setTimeout(() => isTop.value = _isTop);
  });
  return {
    isTop: readonly(isTop)
  };
}

// node_modules/vuetify/lib/composables/overlay.mjs
var VuetifyOverlayKey = Symbol.for("vuetify:overlay");
var ROOT_ZINDEX = 2e3;
function useOverlay(isActive) {
  const {
    zIndex,
    overlays
  } = inject(VuetifyOverlayKey, {
    zIndex: ref(ROOT_ZINDEX),
    overlays: ref([])
  });
  const id = getUid();
  watch(isActive, (value) => {
    if (value) {
      overlays.value.push(id);
    } else {
      overlays.value = overlays.value.filter((x) => x !== id);
    }
  }, {
    immediate: true
  });
  provide(VuetifyOverlayKey, {
    zIndex,
    overlays
  });
  const overlayZIndex = computed(() => zIndex.value + overlays.value.indexOf(id) + 1);
  return {
    overlayZIndex
  };
}

// node_modules/vuetify/lib/directives/click-outside/index.mjs
function defaultConditional() {
  return true;
}
function checkEvent(e, el, binding) {
  if (!e || checkIsActive(e, binding) === false)
    return false;
  const root = attachedRoot(el);
  if (typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot && root.host === e.target)
    return false;
  const elements = (typeof binding.value === "object" && binding.value.include || (() => []))();
  elements.push(el);
  return !elements.some((el2) => el2 == null ? void 0 : el2.contains(e.target));
}
function checkIsActive(e, binding) {
  const isActive = typeof binding.value === "object" && binding.value.closeConditional || defaultConditional;
  return isActive(e);
}
function directive(e, el, binding) {
  const handler = typeof binding.value === "function" ? binding.value : binding.value.handler;
  el._clickOutside.lastMousedownWasOutside && checkEvent(e, el, binding) && setTimeout(() => {
    checkIsActive(e, binding) && handler && handler(e);
  }, 0);
}
function handleShadow(el, callback) {
  const root = attachedRoot(el);
  callback(document);
  if (typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot) {
    callback(root);
  }
}
var ClickOutside = {
  mounted(el, binding) {
    const onClick = (e) => directive(e, el, binding);
    const onMousedown = (e) => {
      el._clickOutside.lastMousedownWasOutside = checkEvent(e, el, binding);
    };
    handleShadow(el, (app) => {
      app.addEventListener("click", onClick, true);
      app.addEventListener("mousedown", onMousedown, true);
    });
    if (!el._clickOutside) {
      el._clickOutside = {
        lastMousedownWasOutside: true
      };
    }
    el._clickOutside[binding.instance.$.uid] = {
      onClick,
      onMousedown
    };
  },
  unmounted(el, binding) {
    if (!el._clickOutside)
      return;
    handleShadow(el, (app) => {
      var _el$_clickOutside;
      if (!app || !((_el$_clickOutside = el._clickOutside) != null && _el$_clickOutside[binding.instance.$.uid]))
        return;
      const {
        onClick,
        onMousedown
      } = el._clickOutside[binding.instance.$.uid];
      app.removeEventListener("click", onClick, true);
      app.removeEventListener("mousedown", onMousedown, true);
    });
    delete el._clickOutside[binding.instance.$.uid];
  }
};

// node_modules/vuetify/lib/components/VOverlay/VOverlay.mjs
function Scrim(props) {
  const _a = props, {
    modelValue,
    color
  } = _a, rest = __objRest(_a, [
    "modelValue",
    "color"
  ]);
  return createVNode(Transition, {
    "name": "fade-transition",
    "appear": true
  }, {
    default: () => [props.modelValue && createVNode("div", mergeProps({
      "class": ["v-overlay__scrim", props.color.backgroundColorClasses.value],
      "style": props.color.backgroundColorStyles.value
    }, rest), null)]
  });
}
var VOverlay = genericComponent()({
  name: "VOverlay",
  directives: {
    ClickOutside
  },
  inheritAttrs: false,
  props: __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    absolute: Boolean,
    attach: [Boolean, String, Object],
    contained: Boolean,
    contentClass: null,
    noClickAnimation: Boolean,
    modelValue: Boolean,
    persistent: Boolean,
    scrim: {
      type: [String, Boolean],
      default: true
    }
  }, makeActivatorProps()), makeDimensionProps()), makePositionStrategyProps()), makeScrollStrategyProps()), makeThemeProps()), makeTransitionProps()), makeLazyProps()),
  emits: {
    "click:outside": (e) => true,
    "update:modelValue": (value) => true,
    afterLeave: () => true
  },
  setup(props, _ref) {
    let {
      slots,
      attrs,
      emit
    } = _ref;
    const isActive = useProxiedModel(props, "modelValue");
    const {
      teleportTarget
    } = useTeleport(computed(() => props.attach || props.contained));
    const {
      themeClasses
    } = provideTheme(props);
    const {
      rtlClasses
    } = useRtl();
    const {
      hasContent,
      onAfterLeave
    } = useLazy(props, isActive);
    const scrimColor = useBackgroundColor(computed(() => {
      return typeof props.scrim === "string" ? props.scrim : null;
    }));
    const {
      activatorEl,
      activatorRef,
      activatorEvents
    } = useActivator(props, isActive);
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      isTop
    } = useStack(isActive);
    const root = ref();
    const contentEl = ref();
    const {
      contentStyles,
      updatePosition
    } = usePositionStrategies(props, {
      contentEl,
      activatorEl,
      isActive
    });
    useScrollStrategies(props, {
      root,
      contentEl,
      activatorEl,
      isActive,
      updatePosition
    });
    function onClickOutside(e) {
      emit("click:outside", e);
      if (!props.persistent)
        isActive.value = false;
      else
        animateClick();
    }
    function closeConditional() {
      return isActive.value && isTop.value;
    }
    IN_BROWSER && watch(isActive, (val) => {
      if (val) {
        window.addEventListener("keydown", onKeydown);
      } else {
        window.removeEventListener("keydown", onKeydown);
      }
    }, {
      immediate: true
    });
    function onKeydown(e) {
      if (e.key === "Escape" && isTop.value) {
        if (!props.persistent) {
          isActive.value = false;
        } else
          animateClick();
      }
    }
    useBackButton((next) => {
      if (isTop.value && isActive.value) {
        next(false);
        if (!props.persistent)
          isActive.value = false;
        else
          animateClick();
      } else {
        next();
      }
    });
    const top = ref();
    watch(() => isActive.value && (props.absolute || props.contained) && teleportTarget.value == null, (val) => {
      if (val) {
        const scrollParent = getScrollParent(root.value);
        if (scrollParent && scrollParent !== document.scrollingElement) {
          top.value = scrollParent.scrollTop;
        }
      }
    });
    function animateClick() {
      var _contentEl$value;
      if (props.noClickAnimation)
        return;
      (_contentEl$value = contentEl.value) == null ? void 0 : _contentEl$value.animate([{
        transformOrigin: "center"
      }, {
        transform: "scale(1.03)"
      }, {
        transformOrigin: "center"
      }], {
        duration: 150,
        easing: standardEasing
      });
    }
    const {
      overlayZIndex
    } = useOverlay(isActive);
    useRender(() => {
      var _slots$activator, _slots$default;
      return createVNode(Fragment, null, [(_slots$activator = slots.activator) == null ? void 0 : _slots$activator.call(slots, {
        isActive: isActive.value,
        props: mergeProps({
          ref: activatorRef
        }, toHandlers(activatorEvents.value), props.activatorProps)
      }), IN_BROWSER && createVNode(Teleport, {
        "disabled": !teleportTarget.value,
        "to": teleportTarget.value
      }, {
        default: () => [hasContent.value && createVNode("div", mergeProps({
          "class": ["v-overlay", {
            "v-overlay--absolute": props.absolute || props.contained,
            "v-overlay--active": isActive.value,
            "v-overlay--contained": props.contained
          }, themeClasses.value, rtlClasses.value],
          "style": {
            top: convertToUnit(top.value),
            zIndex: overlayZIndex.value
          },
          "ref": root
        }, attrs), [createVNode(Scrim, {
          "color": scrimColor,
          "modelValue": isActive.value && !!props.scrim
        }, null), createVNode(MaybeTransition, {
          "appear": true,
          "persisted": true,
          "transition": props.transition,
          "target": activatorEl.value,
          "onAfterLeave": () => {
            onAfterLeave();
            emit("afterLeave");
          }
        }, {
          default: () => [withDirectives(createVNode("div", {
            "ref": contentEl,
            "class": ["v-overlay__content", props.contentClass],
            "style": [dimensionStyles.value, contentStyles.value]
          }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
            isActive
          })]), [[vShow, isActive.value], [resolveDirective("click-outside"), {
            handler: onClickOutside,
            closeConditional,
            include: () => [activatorEl.value]
          }]])]
        })])]
      })]);
    });
    return {
      animateClick,
      contentEl,
      activatorEl
    };
  }
});

// node_modules/vuetify/lib/components/VMenu/VMenu.mjs
var VMenu = genericComponent()({
  name: "VMenu",
  inheritAttrs: false,
  props: __spreadValues({
    disableKeys: Boolean,
    modelValue: Boolean,
    id: String
  }, makeTransitionProps({
    transition: {
      component: VDialogTransition
    }
  })),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const isActive = useProxiedModel(props, "modelValue");
    const uid = getUid();
    const id = computed(() => props.id || `v-menu-${uid}`);
    return () => {
      return createVNode(VOverlay, mergeProps({
        "modelValue": isActive.value,
        "onUpdate:modelValue": ($event) => isActive.value = $event,
        "class": ["v-menu"],
        "transition": props.transition,
        "absolute": true,
        "positionStrategy": "connected",
        "scrollStrategy": "reposition",
        "scrim": false,
        "activatorProps": {
          "aria-haspopup": "menu",
          "aria-expanded": String(isActive.value),
          "aria-owns": id.value
        }
      }, attrs), {
        default: slots.default,
        activator: slots.activator
      });
    };
  }
});
export {
  VMenu
};
//# sourceMappingURL=vuetify_lib_components_VMenu_index_mjs.js.map
