import {
  VAvatar,
  makeVAvatarProps
} from "./chunk-DNJ6SOTR.js";
import {
  VExpandTransition
} from "./chunk-ECUIDIJC.js";
import {
  useSelectLink
} from "./chunk-WE4DPN5G.js";
import {
  VDefaultsProvider
} from "./chunk-2UHGBGKB.js";
import {
  genOverlays,
  makeVariantProps,
  useVariant
} from "./chunk-D2XP5QHS.js";
import {
  Ripple,
  VIcon,
  makeDensityProps,
  makeVIconProps,
  useDensity
} from "./chunk-WLPJEKET.js";
import {
  makeDimensionProps,
  useDimension
} from "./chunk-CHKNSBGH.js";
import "./chunk-ZORWLBYQ.js";
import "./chunk-HKKIYXXJ.js";
import {
  makeBorderProps,
  makeElevationProps,
  makeRoundedProps,
  useBorder,
  useElevation,
  useRounded
} from "./chunk-KB2W3AZ5.js";
import {
  makeRouterProps,
  useLink
} from "./chunk-AVUVHU2D.js";
import {
  useProxiedModel
} from "./chunk-OLD5LPCW.js";
import {
  useBackgroundColor,
  useTextColor
} from "./chunk-7WR4I7IW.js";
import {
  makeThemeProps,
  provideTheme
} from "./chunk-3GMUFSDV.js";
import {
  makeTagProps
} from "./chunk-THFDFTRQ.js";
import {
  convertToUnit,
  createSimpleFunctional,
  defineComponent,
  genericComponent,
  getCurrentInstance,
  getUid,
  propsFactory,
  provideDefaults,
  useRender
} from "./chunk-ALJB2OGJ.js";
import {
  Fragment,
  computed,
  createVNode,
  inject,
  mergeProps,
  onBeforeUnmount,
  onMounted,
  provide,
  ref,
  resolveDirective,
  toRef,
  vShow,
  watch,
  withDirectives
} from "./chunk-2JUOC7J6.js";
import {
  __objRest,
  __spreadProps,
  __spreadValues
} from "./chunk-AWPMEBIP.js";

// node_modules/vuetify/lib/components/VList/VList.mjs
import "/Users/zhijunsong/Documents/vitetestbuild/node_modules/vuetify/lib/components/VList/VList.css";

// node_modules/vuetify/lib/components/VDivider/VDivider.mjs
import "/Users/zhijunsong/Documents/vitetestbuild/node_modules/vuetify/lib/components/VDivider/VDivider.css";
var VDivider = defineComponent({
  name: "VDivider",
  props: __spreadValues({
    color: String,
    inset: Boolean,
    length: [Number, String],
    thickness: [Number, String],
    vertical: Boolean
  }, makeThemeProps()),
  setup(props, _ref) {
    let {
      attrs
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "color"));
    const dividerStyles = computed(() => {
      const styles = {};
      if (props.length) {
        styles[props.vertical ? "maxHeight" : "maxWidth"] = convertToUnit(props.length);
      }
      if (props.thickness) {
        styles[props.vertical ? "borderRightWidth" : "borderTopWidth"] = convertToUnit(props.thickness);
      }
      return styles;
    });
    return () => {
      return createVNode("hr", {
        "class": [{
          "v-divider": true,
          "v-divider--inset": props.inset,
          "v-divider--vertical": props.vertical
        }, themeClasses.value, backgroundColorClasses.value],
        "style": [dividerStyles.value, backgroundColorStyles.value],
        "aria-orientation": !attrs.role || attrs.role === "separator" ? props.vertical ? "vertical" : "horizontal" : void 0,
        "role": `${attrs.role || "separator"}`
      }, null);
    };
  }
});

// node_modules/vuetify/lib/components/VList/list.mjs
var DepthKey = Symbol.for("vuetify:depth");
var ListKey = Symbol.for("vuetify:list");
function createList() {
  const parent = inject(ListKey, {
    hasPrepend: ref(false),
    updateHasPrepend: () => null
  });
  const data = {
    hasPrepend: ref(false),
    updateHasPrepend: (value) => {
      if (value)
        data.hasPrepend.value = value;
    }
  };
  provide(ListKey, data);
  return parent;
}
function useList() {
  return inject(ListKey, null);
}

// node_modules/vuetify/lib/composables/nested/openStrategies.mjs
var singleOpenStrategy = (_ref) => {
  let {
    id,
    value,
    opened,
    parents
  } = _ref;
  if (value) {
    const newOpened = /* @__PURE__ */ new Set();
    newOpened.add(id);
    let parent = parents.get(id);
    while (parent != null) {
      newOpened.add(parent);
      parent = parents.get(parent);
    }
    return newOpened;
  } else {
    opened.delete(id);
    return opened;
  }
};
var multipleOpenStrategy = (_ref2) => {
  let {
    id,
    value,
    opened,
    parents
  } = _ref2;
  if (value) {
    let parent = parents.get(id);
    opened.add(id);
    while (parent != null && parent !== id) {
      opened.add(parent);
      parent = parents.get(parent);
    }
    return opened;
  } else {
    opened.delete(id);
  }
  return opened;
};

// node_modules/vuetify/lib/composables/nested/selectStrategies.mjs
var independentSelectStrategy = (mandatory) => {
  const strategy = {
    select: (_ref) => {
      let {
        id,
        value,
        selected
      } = _ref;
      if (mandatory && !value) {
        const on = Array.from(selected.entries()).reduce((arr, _ref2) => {
          let [key, value2] = _ref2;
          return value2 === "on" ? [...arr, key] : arr;
        }, []);
        if (on.length === 1 && on[0] === id)
          return selected;
      }
      selected.set(id, value ? "on" : "off");
      return selected;
    },
    in: (v, children, parents) => {
      let map = /* @__PURE__ */ new Map();
      for (const id of v || []) {
        map = strategy.select({
          id,
          value: true,
          selected: new Map(map),
          children,
          parents
        });
      }
      return map;
    },
    out: (v) => {
      const arr = [];
      for (const [key, value] of v.entries()) {
        if (value === "on")
          arr.push(key);
      }
      return arr;
    }
  };
  return strategy;
};
var independentSingleSelectStrategy = (mandatory) => {
  const parentStrategy = independentSelectStrategy(mandatory);
  const strategy = {
    select: (_ref3) => {
      let _a = _ref3, {
        selected,
        id
      } = _a, rest = __objRest(_a, [
        "selected",
        "id"
      ]);
      const singleSelected = selected.has(id) ? /* @__PURE__ */ new Map([[id, selected.get(id)]]) : /* @__PURE__ */ new Map();
      return parentStrategy.select(__spreadProps(__spreadValues({}, rest), {
        id,
        selected: singleSelected
      }));
    },
    in: (v, children, parents) => {
      let map = /* @__PURE__ */ new Map();
      if (v != null && v.length) {
        map = parentStrategy.in(v.slice(0, 1), children, parents);
      }
      return map;
    },
    out: (v, children, parents) => {
      return parentStrategy.out(v, children, parents);
    }
  };
  return strategy;
};
var leafSelectStrategy = (mandatory) => {
  const parentStrategy = independentSelectStrategy(mandatory);
  const strategy = {
    select: (_ref4) => {
      let _a = _ref4, {
        id,
        selected,
        children
      } = _a, rest = __objRest(_a, [
        "id",
        "selected",
        "children"
      ]);
      if (children.has(id))
        return selected;
      return parentStrategy.select(__spreadValues({
        id,
        selected,
        children
      }, rest));
    },
    in: parentStrategy.in,
    out: parentStrategy.out
  };
  return strategy;
};
var leafSingleSelectStrategy = (mandatory) => {
  const parentStrategy = independentSingleSelectStrategy(mandatory);
  const strategy = {
    select: (_ref5) => {
      let _a = _ref5, {
        id,
        selected,
        children
      } = _a, rest = __objRest(_a, [
        "id",
        "selected",
        "children"
      ]);
      if (children.has(id))
        return selected;
      return parentStrategy.select(__spreadValues({
        id,
        selected,
        children
      }, rest));
    },
    in: parentStrategy.in,
    out: parentStrategy.out
  };
  return strategy;
};
var classicSelectStrategy = (mandatory) => {
  const strategy = {
    select: (_ref6) => {
      let {
        id,
        value,
        selected,
        children,
        parents
      } = _ref6;
      const original = new Map(selected);
      const items = [id];
      while (items.length) {
        const item = items.shift();
        selected.set(item, value ? "on" : "off");
        if (children.has(item)) {
          items.push(...children.get(item));
        }
      }
      let parent = parents.get(id);
      while (parent) {
        const childrenIds = children.get(parent);
        const everySelected = childrenIds.every((cid) => selected.get(cid) === "on");
        const noneSelected = childrenIds.every((cid) => !selected.has(cid) || selected.get(cid) === "off");
        selected.set(parent, everySelected ? "on" : noneSelected ? "off" : "indeterminate");
        parent = parents.get(parent);
      }
      if (mandatory && !value) {
        const on = Array.from(selected.entries()).reduce((arr, _ref7) => {
          let [key, value2] = _ref7;
          return value2 === "on" ? [...arr, key] : arr;
        }, []);
        if (on.length === 0)
          return original;
      }
      return selected;
    },
    in: (v, children, parents) => {
      let map = /* @__PURE__ */ new Map();
      for (const id of v || []) {
        map = strategy.select({
          id,
          value: true,
          selected: new Map(map),
          children,
          parents
        });
      }
      return map;
    },
    out: (v, children) => {
      const arr = [];
      for (const [key, value] of v.entries()) {
        if (value === "on" && !children.has(key))
          arr.push(key);
      }
      return arr;
    }
  };
  return strategy;
};

// node_modules/vuetify/lib/composables/nested/nested.mjs
var VNestedSymbol = Symbol.for("vuetify:nested");
var emptyNested = {
  id: ref(),
  root: {
    register: () => null,
    unregister: () => null,
    parents: ref(/* @__PURE__ */ new Map()),
    children: ref(/* @__PURE__ */ new Map()),
    open: () => null,
    select: () => null,
    opened: ref(/* @__PURE__ */ new Set()),
    selected: ref(/* @__PURE__ */ new Map()),
    selectedValues: ref([])
  }
};
var makeNestedProps = propsFactory({
  selectStrategy: [String, Function],
  openStrategy: [String, Function],
  opened: Array,
  selected: Array,
  mandatory: Boolean
}, "nested");
var useNested = (props) => {
  let isUnmounted = false;
  const children = ref(/* @__PURE__ */ new Map());
  const parents = ref(/* @__PURE__ */ new Map());
  const opened = useProxiedModel(props, "opened", props.opened, (v) => new Set(v), (v) => [...v.values()]);
  const selectStrategy = computed(() => {
    if (typeof props.selectStrategy === "object")
      return props.selectStrategy;
    switch (props.selectStrategy) {
      case "single-leaf":
        return leafSingleSelectStrategy(props.mandatory);
      case "leaf":
        return leafSelectStrategy(props.mandatory);
      case "independent":
        return independentSelectStrategy(props.mandatory);
      case "single-independent":
        return independentSingleSelectStrategy(props.mandatory);
      case "classic":
      default:
        return classicSelectStrategy(props.mandatory);
    }
  });
  const openStrategy = computed(() => {
    if (typeof props.openStrategy === "function")
      return props.openStrategy;
    switch (props.openStrategy) {
      case "single":
        return singleOpenStrategy;
      case "multiple":
      default:
        return multipleOpenStrategy;
    }
  });
  const selected = useProxiedModel(props, "selected", props.selected, (v) => selectStrategy.value.in(v, children.value, parents.value), (v) => selectStrategy.value.out(v, children.value, parents.value));
  onBeforeUnmount(() => {
    isUnmounted = true;
  });
  function getPath(id) {
    const path = [];
    let parent = id;
    while (parent != null) {
      path.unshift(parent);
      parent = parents.value.get(parent);
    }
    return path;
  }
  const vm = getCurrentInstance("nested");
  const nested = {
    id: ref(),
    root: {
      opened,
      selected,
      selectedValues: computed(() => {
        const arr = [];
        for (const [key, value] of selected.value.entries()) {
          if (value === "on")
            arr.push(key);
        }
        return arr;
      }),
      register: (id, parentId, isGroup) => {
        parentId && id !== parentId && parents.value.set(id, parentId);
        isGroup && children.value.set(id, []);
        if (parentId != null) {
          children.value.set(parentId, [...children.value.get(parentId) || [], id]);
        }
      },
      unregister: (id) => {
        if (isUnmounted)
          return;
        children.value.delete(id);
        const parent = parents.value.get(id);
        if (parent) {
          var _children$value$get;
          const list = (_children$value$get = children.value.get(parent)) != null ? _children$value$get : [];
          children.value.set(parent, list.filter((child) => child !== id));
        }
        parents.value.delete(id);
        opened.value.delete(id);
      },
      open: (id, value, event) => {
        vm.emit("click:open", {
          id,
          value,
          path: getPath(id),
          event
        });
        const newOpened = openStrategy.value({
          id,
          value,
          opened: new Set(opened.value),
          children: children.value,
          parents: parents.value,
          event
        });
        newOpened && (opened.value = newOpened);
      },
      select: (id, value, event) => {
        vm.emit("click:select", {
          id,
          value,
          path: getPath(id),
          event
        });
        const newSelected = selectStrategy.value.select({
          id,
          value,
          selected: new Map(selected.value),
          children: children.value,
          parents: parents.value,
          event
        });
        newSelected && (selected.value = newSelected);
      },
      children,
      parents
    }
  };
  provide(VNestedSymbol, nested);
  return nested.root;
};
var useNestedItem = (id, isGroup) => {
  const parent = inject(VNestedSymbol, emptyNested);
  const computedId = computed(() => {
    var _id$value;
    return (_id$value = id.value) != null ? _id$value : getUid().toString();
  });
  const item = __spreadProps(__spreadValues({}, parent), {
    id: computedId,
    open: (open, e) => parent.root.open(computedId.value, open, e),
    isOpen: computed(() => parent.root.opened.value.has(computedId.value)),
    parent: computed(() => parent.root.parents.value.get(computedId.value)),
    select: (selected, e) => parent.root.select(computedId.value, selected, e),
    isSelected: computed(() => parent.root.selected.value.get(computedId.value) === "on"),
    isIndeterminate: computed(() => parent.root.selected.value.get(computedId.value) === "indeterminate"),
    isLeaf: computed(() => !parent.root.children.value.get(computedId.value)),
    isGroupActivator: parent.isGroupActivator
  });
  !parent.isGroupActivator && parent.root.register(computedId.value, parent.id.value, isGroup);
  onBeforeUnmount(() => {
    !parent.isGroupActivator && parent.root.unregister(computedId.value);
  });
  isGroup && provide(VNestedSymbol, item);
  return item;
};
var useNestedGroupActivator = () => {
  const parent = inject(VNestedSymbol, emptyNested);
  provide(VNestedSymbol, __spreadProps(__spreadValues({}, parent), {
    isGroupActivator: true
  }));
};

// node_modules/vuetify/lib/components/VList/VListGroup.mjs
var VListGroupActivator = defineComponent({
  name: "VListGroupActivator",
  setup(_, _ref) {
    let {
      slots
    } = _ref;
    useNestedGroupActivator();
    return () => {
      var _slots$default;
      return (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots);
    };
  }
});
var VListGroup = genericComponent()({
  name: "VListGroup",
  props: __spreadValues({
    activeColor: String,
    color: String,
    collapseIcon: {
      type: String,
      default: "$collapse"
    },
    expandIcon: {
      type: String,
      default: "$expand"
    },
    value: null
  }, makeTagProps()),
  setup(props, _ref2) {
    let {
      slots
    } = _ref2;
    const {
      isOpen,
      open
    } = useNestedItem(toRef(props, "value"), true);
    const list = useList();
    const onClick = (e) => {
      open(!isOpen.value, e);
    };
    const activatorProps = computed(() => {
      var _props$activeColor;
      return {
        onClick,
        appendIcon: isOpen.value ? props.collapseIcon : props.expandIcon,
        class: "v-list-group__header",
        color: isOpen.value ? (_props$activeColor = props.activeColor) != null ? _props$activeColor : props.color : void 0
      };
    });
    return () => {
      var _slots$default2;
      return createVNode(props.tag, {
        "class": ["v-list-group", {
          "v-list-group--prepend": list == null ? void 0 : list.hasPrepend.value
        }]
      }, {
        default: () => [slots.activator && createVNode(VDefaultsProvider, {
          "defaults": {
            VListItemIcon: {
              color: activatorProps.value.color
            }
          }
        }, {
          default: () => [createVNode(VListGroupActivator, null, {
            default: () => [slots.activator({
              props: activatorProps.value,
              isOpen
            })]
          })]
        }), createVNode(VExpandTransition, null, {
          default: () => [withDirectives(createVNode("div", {
            "class": "v-list-group__items"
          }, [(_slots$default2 = slots.default) == null ? void 0 : _slots$default2.call(slots)]), [[vShow, isOpen.value]])]
        })]
      });
    };
  }
});

// node_modules/vuetify/lib/components/VList/VListItem.mjs
import "/Users/zhijunsong/Documents/vitetestbuild/node_modules/vuetify/lib/components/VList/VListItem.css";

// node_modules/vuetify/lib/components/VList/VListItemAvatar.mjs
var VListItemAvatar = defineComponent({
  name: "VListItemAvatar",
  props: makeVAvatarProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    return () => createVNode(VAvatar, mergeProps({
      "class": ["v-list-item-avatar", {
        "v-list-item-avatar--start": props.start,
        "v-list-item-avatar--end": props.end
      }]
    }, props), slots);
  }
});

// node_modules/vuetify/lib/components/VList/VListItemHeader.mjs
var VListItemHeader = createSimpleFunctional("v-list-item-header");

// node_modules/vuetify/lib/components/VList/VListItemIcon.mjs
var VListItemIcon = defineComponent({
  name: "VListItemIcon",
  props: makeVIconProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    return () => createVNode(VIcon, mergeProps({
      "class": ["v-list-item-icon", {
        "v-list-item-icon--start": props.start,
        "v-list-item-icon--end": props.end
      }]
    }, props), slots);
  }
});

// node_modules/vuetify/lib/components/VList/VListItemSubtitle.mjs
var VListItemSubtitle = createSimpleFunctional("v-list-item-subtitle");

// node_modules/vuetify/lib/components/VList/VListItemTitle.mjs
var VListItemTitle = createSimpleFunctional("v-list-item-title");

// node_modules/vuetify/lib/components/VList/VListItem.mjs
var VListItem = genericComponent()({
  name: "VListItem",
  directives: {
    Ripple
  },
  props: __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    active: Boolean,
    activeColor: String,
    activeClass: String,
    appendAvatar: String,
    appendIcon: String,
    disabled: Boolean,
    lines: String,
    nav: Boolean,
    prependAvatar: String,
    prependIcon: String,
    subtitle: String,
    title: String,
    value: null
  }, makeBorderProps()), makeDensityProps()), makeDimensionProps()), makeElevationProps()), makeRoundedProps()), makeRouterProps()), makeTagProps()), makeThemeProps()), makeVariantProps({
    variant: "text"
  })),
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const link = useLink(props, attrs);
    const id = computed(() => {
      var _props$value;
      return (_props$value = props.value) != null ? _props$value : link.href.value;
    });
    const {
      select,
      isSelected,
      isIndeterminate,
      isGroupActivator,
      root,
      parent
    } = useNestedItem(id, false);
    const list = useList();
    const isActive = computed(() => {
      var _link$isExactActive;
      return props.active || ((_link$isExactActive = link.isExactActive) == null ? void 0 : _link$isExactActive.value) || isSelected.value;
    });
    const roundedProps = computed(() => props.rounded || props.nav);
    const variantProps = computed(() => {
      var _props$activeColor;
      return {
        color: isActive.value ? (_props$activeColor = props.activeColor) != null ? _props$activeColor : props.color : props.color,
        variant: props.variant
      };
    });
    onMounted(() => {
      var _link$isExactActive2;
      if ((_link$isExactActive2 = link.isExactActive) != null && _link$isExactActive2.value && parent.value != null) {
        root.open(parent.value, true);
      }
    });
    watch(() => {
      var _link$isExactActive3;
      return (_link$isExactActive3 = link.isExactActive) == null ? void 0 : _link$isExactActive3.value;
    }, (val) => {
      if (val && parent.value != null) {
        root.open(parent.value, true);
      }
    });
    const {
      themeClasses
    } = provideTheme(props);
    const {
      borderClasses
    } = useBorder(props);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(variantProps);
    const {
      densityClasses
    } = useDensity(props);
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(roundedProps);
    const lineClasses = computed(() => props.lines ? `v-list-item--${props.lines}-line` : void 0);
    const slotProps = computed(() => ({
      isActive: isActive.value,
      select,
      isSelected: isSelected.value,
      isIndeterminate: isIndeterminate.value
    }));
    useSelectLink(link, select);
    useRender(() => {
      var _slots$prepend, _slots$default, _slots$append;
      const Tag = link.isLink.value ? "a" : props.tag;
      const hasColor = !list || isSelected.value || isActive.value;
      const hasTitle = slots.title || props.title;
      const hasSubtitle = slots.subtitle || props.subtitle;
      const hasHeader = !!(hasTitle || hasSubtitle);
      const hasAppend = !!(slots.append || props.appendAvatar || props.appendIcon);
      const hasPrepend = !!(slots.prepend || props.prependAvatar || props.prependIcon);
      const isClickable = !props.disabled && (link.isClickable.value || props.value != null && !!list);
      list == null ? void 0 : list.updateHasPrepend(hasPrepend);
      return withDirectives(createVNode(Tag, {
        "class": ["v-list-item", {
          "v-list-item--active": isActive.value,
          "v-list-item--disabled": props.disabled,
          "v-list-item--link": isClickable,
          "v-list-item--nav": props.nav,
          "v-list-item--prepend": !hasPrepend && (list == null ? void 0 : list.hasPrepend.value),
          [`${props.activeClass}`]: isActive.value
        }, themeClasses.value, borderClasses.value, hasColor ? colorClasses.value : void 0, densityClasses.value, elevationClasses.value, lineClasses.value, roundedClasses.value, variantClasses.value],
        "style": [hasColor ? colorStyles.value : void 0, dimensionStyles.value],
        "href": link.href.value,
        "tabindex": isClickable ? 0 : void 0,
        "onClick": isClickable && ((e) => {
          var _link$navigate;
          if (isGroupActivator)
            return;
          (_link$navigate = link.navigate) == null ? void 0 : _link$navigate.call(link, e);
          select(!isSelected.value, e);
        })
      }, {
        default: () => [genOverlays(isClickable || isActive.value, "v-list-item"), hasPrepend && createVNode(Fragment, null, [props.prependAvatar && createVNode(VListItemAvatar, {
          "image": props.prependAvatar,
          "start": true
        }, null), props.prependIcon && createVNode(VListItemIcon, {
          "icon": props.prependIcon,
          "start": true
        }, null), (_slots$prepend = slots.prepend) == null ? void 0 : _slots$prepend.call(slots, slotProps.value)]), hasHeader && createVNode(VListItemHeader, null, {
          default: () => [hasTitle && createVNode(VListItemTitle, null, {
            default: () => [slots.title ? slots.title({
              title: props.title
            }) : props.title]
          }), hasSubtitle && createVNode(VListItemSubtitle, null, {
            default: () => [slots.subtitle ? slots.subtitle({
              subtitle: props.subtitle
            }) : props.subtitle]
          })]
        }), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, slotProps.value), hasAppend && createVNode(Fragment, null, [(_slots$append = slots.append) == null ? void 0 : _slots$append.call(slots, slotProps.value), props.appendAvatar && createVNode(VListItemAvatar, {
          "image": props.appendAvatar,
          "end": true
        }, null), props.appendIcon && createVNode(VListItemIcon, {
          "icon": props.appendIcon,
          "end": true
        }, null)])]
      }), [[resolveDirective("ripple"), isClickable]]);
    });
  }
});

// node_modules/vuetify/lib/components/VList/VListSubheader.mjs
var VListSubheader = defineComponent({
  name: "VListSubheader",
  props: __spreadValues({
    color: String,
    inset: Boolean,
    sticky: Boolean,
    text: String
  }, makeTagProps()),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "color"));
    return () => {
      var _slots$default, _slots$default2;
      const hasText = !!(slots.default || props.text);
      return createVNode(props.tag, {
        "class": ["v-list-subheader", {
          "v-list-subheader--inset": props.inset,
          "v-list-subheader--sticky": props.sticky
        }, textColorClasses.value],
        "style": {
          textColorStyles
        }
      }, {
        default: () => [hasText && createVNode("div", {
          "class": "v-list-subheader__text"
        }, [(_slots$default = (_slots$default2 = slots.default) == null ? void 0 : _slots$default2.call(slots)) != null ? _slots$default : props.text])]
      });
    };
  }
});

// node_modules/vuetify/lib/components/VList/VListChildren.mjs
var VListChildren = genericComponent()({
  name: "VListChildren",
  props: {
    items: Array
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    createList();
    return () => {
      var _slots$default, _slots$default2, _props$items;
      return (_slots$default = (_slots$default2 = slots.default) == null ? void 0 : _slots$default2.call(slots)) != null ? _slots$default : (_props$items = props.items) == null ? void 0 : _props$items.map((_ref2) => {
        let {
          children,
          props: itemProps,
          type
        } = _ref2;
        if (type === "divider")
          return createVNode(VDivider, itemProps, null);
        if (type === "subheader")
          return createVNode(VListSubheader, itemProps, slots);
        return children ? createVNode(VListGroup, {
          "value": itemProps == null ? void 0 : itemProps.value
        }, {
          activator: (_ref3) => {
            let {
              props: activatorProps
            } = _ref3;
            return slots.header ? slots.header(__spreadValues(__spreadValues({}, itemProps), activatorProps)) : createVNode(VListItem, mergeProps(itemProps, activatorProps), slots);
          },
          default: () => createVNode(VListChildren, {
            "items": children
          }, slots)
        }) : slots.item ? slots.item(itemProps) : createVNode(VListItem, itemProps, slots);
      });
    };
  }
});

// node_modules/vuetify/lib/components/VList/VList.mjs
var parseItems = (items) => {
  if (!items)
    return void 0;
  return items.map((item) => {
    if (typeof item === "string")
      return {
        type: "item",
        value: item,
        title: item
      };
    const _a = item, {
      $type,
      $children
    } = _a, props = __objRest(_a, [
      "$type",
      "$children"
    ]);
    if ($type === "subheader")
      return {
        type: "subheader",
        props
      };
    if ($type === "divider")
      return {
        type: "divider",
        props
      };
    return {
      type: "item",
      props,
      children: parseItems($children)
    };
  });
};
var VList = genericComponent()({
  name: "VList",
  props: __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({
    activeColor: String,
    activeClass: String,
    bgColor: String,
    disabled: Boolean,
    lines: {
      type: [Boolean, String],
      default: "one"
    },
    nav: Boolean,
    items: Array
  }, makeNestedProps({
    selectStrategy: "single-leaf",
    openStrategy: "multiple"
  })), makeBorderProps()), makeDensityProps()), makeDimensionProps()), makeElevationProps()), makeRoundedProps()), makeTagProps()), makeThemeProps()), makeVariantProps({
    variant: "text"
  })),
  emits: {
    "update:selected": (val) => true,
    "update:opened": (val) => true,
    "click:open": (value) => true,
    "click:select": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const items = computed(() => parseItems(props.items));
    const {
      themeClasses
    } = provideTheme(props);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "bgColor"));
    const {
      borderClasses
    } = useBorder(props);
    const {
      densityClasses
    } = useDensity(props);
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      open,
      select
    } = useNested(props);
    const lineClasses = computed(() => props.lines ? `v-list--${props.lines}-line` : void 0);
    const activeColor = toRef(props, "activeColor");
    const color = toRef(props, "color");
    createList();
    provideDefaults({
      VListGroup: {
        activeColor,
        color
      },
      VListItem: {
        activeClass: toRef(props, "activeClass"),
        activeColor,
        color,
        density: toRef(props, "density"),
        disabled: toRef(props, "disabled"),
        lines: toRef(props, "lines"),
        nav: toRef(props, "nav"),
        variant: toRef(props, "variant")
      }
    });
    useRender(() => {
      return createVNode(props.tag, {
        "class": ["v-list", {
          "v-list--disabled": props.disabled,
          "v-list--nav": props.nav
        }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, lineClasses.value, roundedClasses.value],
        "style": [backgroundColorStyles.value, dimensionStyles.value]
      }, {
        default: () => [createVNode(VListChildren, {
          "items": items.value
        }, slots)]
      });
    });
    return {
      open,
      select
    };
  }
});

// node_modules/vuetify/lib/components/VList/VListImg.mjs
var VListImg = createSimpleFunctional("v-list-img");

// node_modules/vuetify/lib/components/VList/VListItemAction.mjs
var VListItemAction = defineComponent({
  name: "VListItemAction",
  props: __spreadValues({
    start: Boolean,
    end: Boolean
  }, makeTagProps()),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    return () => {
      return createVNode(props.tag, {
        "class": ["v-list-item-action", {
          "v-list-item-action--start": props.start,
          "v-list-item-action--end": props.end
        }]
      }, slots);
    };
  }
});

// node_modules/vuetify/lib/components/VList/VListItemMedia.mjs
var VListItemMedia = defineComponent({
  name: "VListItemMedia",
  props: __spreadValues({
    start: Boolean,
    end: Boolean
  }, makeTagProps()),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    return () => {
      return createVNode(props.tag, {
        "class": ["v-list-item-media", {
          "v-list-item-media--start": props.start,
          "v-list-item-media--end": props.end
        }]
      }, slots);
    };
  }
});
export {
  VList,
  VListGroup,
  VListImg,
  VListItem,
  VListItemAction,
  VListItemAvatar,
  VListItemHeader,
  VListItemIcon,
  VListItemMedia,
  VListItemSubtitle,
  VListItemTitle,
  VListSubheader
};
//# sourceMappingURL=vuetify_lib_components_VList_index_mjs.js.map
